<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[两数之和]]></title>
    <url>%2F2018%2F04%2F25%2Ftwo-sum%2F</url>
    <content type="text"><![CDATA[给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例: 1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 方法一思路：根据冒泡的方式，遍历数组，两数字之和等于目标值则找到。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; for (int i = 0; i &lt; nums.length - 1; i ++)&#123; for (int j = i +1; j &lt; nums.length; j ++) &#123; if (nums[i] + nums[j] == target) &#123; return new int[]&#123;i, j&#125;; &#125; &#125; &#125; return null; &#125;&#125; 总结：上述方式遍历2次数组，效率不高； 方法二思路：根据target，数组遍历当前值，查找差值是否在数组中。 123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; if (nums == null || nums.length &lt;= 1) &#123; return null; &#125; Map&lt;Integer, Integer&gt; filter = new HashMap(); for (int i = 0; i &lt; nums.length; i ++)&#123; if (filter.containsKey(target - nums[i])) &#123; return new int[]&#123;i, filter.get(target - nums[i])&#125;; &#125; filter.put(nums[i], i); &#125; return null; &#125;&#125; 总结：数组仅遍历一次，效率提高；利用HashMap实现值和索引的配对。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>两数之和</tag>
      </tags>
  </entry>
</search>
